
# SpringTaskManager

Приложение-календарь с распорядком дня и бронированием временных интервалов.    




## Предназначение и возможности приложения
Приложение написано на фреймворке Spring Boot и JDK 21   

Приложение собирается с помощь утилиты сборки ```maven```

Приложение работает с БД MySQL 

Приложение содержит REST-API для обработки запросов (примеры запросов и требования к переданным данным будут ниже) 
  
На данный момент реализован MVP (Minimum viable product) с основными функциями:



- Создание пользователя в БД
- Удаление пользователя из БД
- Обновление полей пользователя в БД
- Получение  пользователя из БД со списком его распорядков дня и всеми задачами на эти дни  
Распорядок дня:
- Создание распорядка дня в БД с привязкой к пользователю
- Обновление распорядка дня в БД
- Удаление распорядка дня в БД 
Событие (временные промежутки, которые можно бронировать на каждый день ):
- Создание события в БД с привязкой к распорядку дня
*реализован механизм защиты от брони на то же время что уже имеется в БД, или на время, которое перекрывается уже забронированным промежутком
#### *Количество функций не является исчерпывающим и предназначено для того чтобы показать основной концепт работы приложения.  


## Модель данных, описывающая предметную область:
В проекте присутствуют 3 основные сущности на основе которых создаются таблицы в БД при первом запуске приложения, или при отсутствии таких таблиц:

Сущность ПОЛЬЗОВАТЕЛЬ UserEntity

| Поле сущности | Тип поля     |
| :-----------  | :------- | 
| `id`          | `long`   |
| `username`    | `string` |
| `password`    | `string` |
| `email`       | `string` |


Сущность РАСПОРЯДОК ДНЯ, которая по сути реализует собой каждую конкретную дату в календаре - DayScheduleEntity

| Поле сущности | Тип поля | Тип поля В БД |
| :-----------  | :------- | :-------      |
| `id`          | `long`   |
| `date`        | `localdate`|  DATE        | 
| `user_id`     | `long` |     

Особенности:  
  - user_id реализован с помощью аннотации``` @JoinColumn(name = "user_id")``` и является полем по которому таблицы будут связаны при помощи аннотации ```@ManyToOne``` связью :   
    один ПОЛЬЗОВАТЕЛЬ - ко многим РАСПОРЯДКАМ ДНЯ
- В БД некорректно ложится тип localdate, необходимо было использовать аннотацию ```@Temporal(TemporalType.DATE)``` чтобы явно указать к какому типу даты необходимо приводить.   Формат даты: 'YYYY-MM-DD'




Сущность СОБЫТИЕ EventEntity 

| Поле сущности | Тип поля     | Тип поля В БД |
| :-----------  | :------- |  :-------      |
| `id`          | `long`   |
| `eventName`    | `string` |
| `eventDescription`| `string` |
| `startTime`       | `localtime` | TIME|
| `endTime`    | `localtime` |TIME |
| `dayschedule_id`| `long` |

Особенности: 
-- dayschedule_id реализован с помощью аннотации``` @JoinColumn(name = "dayschedule_id")``` и является полем по которому таблицы будут связаны при помощи аннотации ```@ManyToOne``` связью :   
    один РАСПОРЯДОК ДНЯ - ко многим СОБЯТИЯМ
- Такая же ситуация с типом данных localtime, используем ```@Temporal(TemporalType.TIME)``` приводим к формату 'HH:MM:SS'

## Структура проекта:
Для каждой сущности реализован свой класс контроллера ```@RestController```, свой класс сервиса  ```@Service```, свой интерфейс репозитория для получения данных из БД и свой класс модели, который необходим для отправки на клиентскую сторону вместо сущностей и сокрытия важных полей, например пароля у пользователя.  
В классе модели пользователя и в классе модели распорядка дня реализован список вложенных объектов с помощью Stream API.

Таким образом в каждой модели **пользователя** хранится список с каждым **распорядком дня**, который принадлежит этому пользователю, а в каждой модели **распорядка дня** хранится список с каждым **событием**, которое ему принадлежит. И при запросе пользователя из БД корректно отображаются вложенные списки в формате JSON.

# REST-API:
Работа REST-API проверялась на клиенте Postman, в теории должно работать и другими способами.


 ## Создать пользователя

```http
  POST http://localhost:8080/api/v1/users/create_user
```
Необходимо в месте с запросом передавать тело формата JSON со следующими полями:  
**Пример JSON**
```
{
    "username":"username",
    "password":"pass1",
    "email":"someMail@gmail.com"
}
```
Создаёт пользователя в БД и возвращает сообщение "Пользователь успешно сохранён". 




## Получить пользователя

```http
  GET http://localhost:8080/api/v1/users?id=1
```
Необходимо вместе с запросом передавать параметр id пользователя, которого мы хотим просмотреть.

Возвращает JSON пользователя с вложенными списками из его распорядков дня и событий в этих днях.

## Обновить пользователя

```http
  PUT http://localhost:8080/api/v1/users/update?userid=2
```
Необходимо в месте с запросом передавать параметр id пользователя, которого мы хотим изменить и тело формата JSON со следующими полями:  
**Пример JSON**
```
{
    "username":"username",
    "password":"pass1",
    "email":"someMail@gmail.com"
}
```
Обновляет пользователя в БД в соответствии с полученными данными из JSON и возвращает уже измененного пользователя.
При некорректных параметрах - выводит сообщение об ошибке

## Удалить пользователя

```http
  DELETE http://localhost:8080/api/v1/users/3
```
Необходимо вместе с запросом передавать параметр адресной строки, например /3 чтобы удалить пользователя с этим id

Удаляет пользователя из БД и возвращает значение id удалённого пользователя.  
(Возможно потом использовать для того чтобы в БД переопределять ID для оставшихся пользователей, сейчас после удаления пользователя с id 1 следующий создавшийся пользователь будет с id 2. Можно реализовать механизм, позволяющий обновлять список id после каждого удаления)

## Создать распорядок дня

```http
  POST http://localhost:8080/api/v1/day_schedule?userId=3
```
Необходимо в месте с запросом передавать параметр userId, показывающий какому пользователю данный распорядок будет принадлежать и тело формата JSON, показывающее на какую дату распорядок дня со следующими полями:  
**Пример JSON**
```
{
    "date":"2024-02-07"
}
```
Создаёт Распорядок дня в БД и возвращает его модель с вложенным списком задач, по умолчанию пустым. 
Если создать на ту же дату, выдаст сообщение что распорядок дня на эту дату уже имеется.

## Обновить распорядок дня

```http
  PUT http://localhost:8080/api/v1/day_schedule/update?id=5
```
Необходимо вместе с запросом передавать параметр id, показывающий какой распорядок дня менять и тело формата JSON с обновленной датой:  
**Пример JSON**
```
{
    "date":"2025-06-17"
}
```
Создаёт Распорядок дня в БД и возвращает его модель с вложенным списком задач, по умолчанию пустым. 

## Удалить распорядок дня

```http
  DELETE http://localhost:8080/api/v1/day_schedule/id
```
Необходимо вместе с запросом передавать параметр адресной строки, например /3 чтобы удалить пользователя с этим id

Удаляет пользователя из БД и возвращает значение id удалённого пользователя.  
(Возможно потом использовать для того чтобы в БД переопределять ID для оставшихся пользователей, сейчас после удаления пользователя с id 1 следующий создавшийся пользователь будет с id 2. Можно реализовать механизм, позволяющий обновлять список id после каждого удаления)

## Создать событие

```http
  POST http://localhost:8080/api/v1/event?dayScheduleid=2
```
Необходимо вместе с запросом передавать параметр id распорядка дня, к которому должно относиться событие и тело формата JSON со следующими полями: 
**Пример JSON**
```
{
    "eventName": "День рождения",
    "eventDescription": "День рождения у подруги Алины",
    "startTime":"00:00:00",
    "endTime":"08:47:00"
}
```
Создаёт событие в БД, привязанное к определённой дате (к определенному распорядку дня). При попытке создать событие в промежуток времени, которое принадлежит другому событию в БД конкретно на эту дату, выдаст сообщение, что промежуток указан некорректно. Возможно установить одинаковые промежутки времени, для разных дат.

## Сборка и запуск приложения

Для сборки приложения потребуется утилита ```maven``` а также установленный JDK 21.

Для запуска приложения необходима пресозданная в локальной сети БД в MySQL с названием sprintTaskManager а также 

**Пользователь СУБД** 
```
username = springuser
password =ThePassword
```
У пользователя должны быть CRUD права

Изменить использующиеся имя пользователя, пароль и имя пресозданной БД в проекте можно в файле src/main/resources/application.properties
меняя соответствующие поля

Создавать таблицы в БД не требуется, приложение создаст их само.
  
Сборка приложения осуществляется в корневой папке проекта командой
```
  mvn package
```
**ВАЖНО! При отсутствии пресозданной БД в MySQL с корректным пользователем сборка не совершится**

Затем в директории проекта /target сформируется исполнительный файл формата .jar
Необходимо запустить приложение (находясь в этой директории) командой 
```
  java -jar *НАЗВАНИЕ_СОЗДАННОГО_ФАЙЛА*.jar
```
Приложение запущено и доступно по адресу localhost:8080

Возможно использование приложения с другими БД, но оно не тестировалось.

## Возможные улучшения и доработки

- **Внедрение Spring Security и авторизации + аутентификации пользователей**  
  Sprin Security почти был добавлен, даже внесены изменения в структуру сущностей, добавлено поле роли для пользователя и механизмы шифрования пароля. Но в новых версиях Spring Security используются другие механизмы для реализации авторизации и аутентификации,а например WebSecurityConfigurerAdapter вообще является depricated. 
  Поэтому я с ними пока ещё не разобрался

- **Добавление новых исключений и усовершенствование механизмов их выброса**  
  Сейчас не для всех методов всегда корректно выкидываются созданные мною исключения
- **Реализация всех методов CRUD для каждой сущности для более удобного тестирования и отладки**
- **Добавление реализации механизма бронирования на несколько дней**  
  Например событие Отпуск будет занимать 3 полных дня, необходимо их объединить в одно целое, хотя они и будут ссылать на разные дни и распорядки дня
- **Сортировка событий по их временным промежуткам** 
   Сейчас при выводе всех событий для пользователя (вложенных списков..) они отображаются в соответствии со своим положением в БД, а не в порядке возрастания.
 - **Ввести проверку входящих значений на соответствие определённому формату, например email** 
- **Реализация пользовательского интерфейса и отображения в виде календаря с датами**

